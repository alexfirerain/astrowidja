package ru.swetophor.РезонанснаяРешётка;

import АстроВидья.Настройки;
import java.util.ArrayList;
import static java.lang.String.format;
import static АстроВидья.Настройки.выводДелителяОрбиса;
import static АстроВидья.НебеснаяМеханика.Механика.*;

public class ВолновойУзор {
    public static void main(String[] args) {
        Роза.показатьУзорДо(23);
        System.out.println(сообщитьОНакладках());
    }

    private static int крайГармоникУзора = Настройки.выводКрайнейГармоники();

    private static String сообщитьОНакладках() {
        if (Роза.узоры.size() == 0) return "Расчёт ещё не выполнен!";
        String сообщение = "";
        int э = 0;
        int п = 0;
        while (э < Роза.узоры.size() - 1) {
            if (Роза.узоры.get(э).выводКонца() > Роза.узоры.get(++э).выводНачала()) {
                сообщение += format("Нахлёст %s между %d/%d (%s) и %d/%d (%s)%n",
                        секундФормат(Роза.узоры.get(--э).выводКонца() - Роза.узоры.get(++э).выводНачала(), true),
                        Роза.узоры.get(--э).крат, Роза.узоры.get(э).гармоника, секундФормат(Роза.узоры.get(э).дуга, true),
                        Роза.узоры.get(++э).крат, Роза.узоры.get(э).гармоника, секундФормат(Роза.узоры.get(э).дуга, true));
                п++;
            } else э++;
        }
        if (п == 0)
            сообщение += format("Никаких пересечений до гармоники %d", крайГармоникУзора);
        else сообщение += format("Всего найдено %d пересечений, считая до гармоники %d", п, крайГармоникУзора);

        сообщение += format(" при орбисе %s (1/%d часть круга)%n",
                секундФормат(КРУГ / выводДелителяОрбиса(), true),
                выводДелителяОрбиса());
        return сообщение;
    }

    private static void показатьУзорДо(int крайГармоник) {
        крайГармоникУзора = крайГармоник;
        ArrayList<Аспект> узоры = new ArrayList <>();
        double единичник;
        int гармоника = 1;
        узоры.add(new Аспект(1, 1));

        while (гармоника <= крайГармоникУзора) {
            единичник = привестиКоординату(КРУГ / гармоника);
            переборКратов:
            for (int крат = 1; крат <= гармоника/2; крат++) {
                for (Аспект ужеЗаписанный : узоры)
                    if (единичник * крат == ужеЗаписанный.дуга) continue переборКратов;
                узоры.add(new Аспект(гармоника, крат));
            }
            гармоника++;
        }

        узоры = аспектыПоПорядку(узоры);
        for (Аспект очередной : узоры) System.out.printf("%2d/%d\t%10s\t(%10s - %10s)%n",
                очередной.крат, очередной.гармоника,
                секундФорматТаблично(очередной.дуга, true),
                секундФорматТаблично(очередной.выводНачала(), true),
                секундФорматТаблично(очередной.выводКонца(), true));
    }

    private static ArrayList<Аспект> аспектыПоПорядку(ArrayList<Аспект> узоры) {
        ArrayList<Аспект> аспектыВПорядке = new ArrayList <>();
            while (аспектыВПорядке.size() < узоры.size()) {
                int очередной = 0;
                while (аспектыВПорядке.contains(узоры.get(очередной))) очередной++;
                if (аспектыВПорядке.size() < узоры.size() - 1) {
                    int следующий = очередной + 1;
                    while (аспектыВПорядке.contains(узоры.get(следующий))) следующий++;
                    while (следующий < узоры.size()) {
                        if (узоры.get(следующий).дуга < узоры.get(очередной).дуга) очередной = следующий;
                        следующий++;
                        while (следующий < узоры.size() && аспектыВПорядке.contains(узоры.get(следующий)))
                            следующий++;
                    }
                }
                аспектыВПорядке.add(узоры.get(очередной));
            }
        return аспектыВПорядке;
    }

    static class Аспект {
        int гармоника;
        int крат;
        double дуга;
        double орбисАспекта;
        public Аспект(int i, int k) {
            this.гармоника = i;
            this.крат = k;
            this.дуга = привестиКоординату(КРУГ / гармоника * крат);
            this.орбисАспекта = КРУГ / выводДелителяОрбиса() / гармоника;
        }
        private double выводНачала() {
            if (дуга - орбисАспекта >= 0) return дуга - орбисАспекта;
            else return 0;
        }

        private double выводКонца() {
            if (дуга + орбисАспекта <= КРУГ/2) return дуга + орбисАспекта;
            else return 180;
        }
        @Override
        public String toString() {
            return секундФормат(дуга, false) + " " + крат + "/" + гармоника
                    + " (" + секундФормат(выводНачала(), false) + " - " + выводКонца() + ")";
        }
    }

    private static class Роза {
        static ArrayList<Аспект> узоры;
        public static void показатьУзорДо(int гармоники) {
            создатьУзор(гармоники);
            for (Аспект очередной : узоры) System.out.printf("%2d/%d\t%10s\t(%10s - %10s)%n",
                    очередной.крат, очередной.гармоника,
                    секундФорматТаблично(очередной.дуга, true),
                    секундФорматТаблично(очередной.выводНачала(), true),
                    секундФорматТаблично(очередной.выводКонца(), true));
        }

        private static void создатьУзор(int гармоники) {
            узоры = new ArrayList <>();
            double единичник;
            int гармоника = 1;
            узоры.add(new Аспект(1, 1));            // до конца не удалось понять, почему нужна эта строка
            while (гармоника <= гармоники) {
                единичник = привестиКоординату(КРУГ / гармоника);
                переборКратов:
                for (int крат = 1; крат <= гармоника/2; крат++) {
                    for (Аспект ужеЗаписанный : узоры)
                        if (единичник * крат == ужеЗаписанный.дуга) continue переборКратов;
                    узоры.add(new Аспект(гармоника, крат));
                }
                гармоника++;
            }
            узоры = аспектыПоПорядку(узоры);
        }

    }
}
