package ru.swetophor.РезонанснаяРешётка;

import АстроВидья.Настройки;
import АстроВидья.НебеснаяМеханика.Астра;
import java.util.ArrayList;
import static АстроВидья.НебеснаяМеханика.Механика.КРУГ;
import static АстроВидья.РезонанснаяРешётка.ТипМатрицы.*;

/** * * * * * * * * * * * * * * * * * * * * * * * * *
 * Двумерная таблица, получающая два массива астр   *
 * и вычисляющая структуру резонансов               *
 * для каждой пары                                  *
 *  * * * * * * * * * * * * * * * * * * * * * * * * */

public class Матрица {
    protected ArrayList<Астра> данные1;
    protected ArrayList<Астра> данные2;
    protected static Резонанс[][] резонансы;
    protected int крайняяГармоника;
    protected int делительОрбиса;
    protected ТипМатрицы тип;

    // методы открытаго доступа к внутренним полям
    public int выводКрайнейГармоники() { return крайняяГармоника; }
    public void вводКрайнейГармоники(int крайняяГармоника) { this.крайняяГармоника = крайняяГармоника; }
    public int выводДелителяОрбиса() { return делительОрбиса; }
    public void вводДелителяОрбиса(int делительОрбиса) { this.делительОрбиса = делительОрбиса; }

    // текстовый вывод матрицы результатов
    public void выводРезультатов() {
        switch (тип) {
            case СИНАСТРИЯ:                                 // таблица всех астр одной на все астры другой
                for (int i = 0; i < данные1.size(); i++)
                    for (int j = 0; j < данные2.size(); j++)
                        резонансы[i][j].выводРезонансов();
                break;
            case КОСМОГРАММА:                               // полутаблица астр карты между собой
                for (int i = 0; i < данные1.size(); i++)
                    for (int j = i + 1; j < данные2.size(); j++)
                        резонансы[i][j].выводРезонансов();
        }
    }

    /// вычисление матрицы для двух массивов (конструктор)
    // из двух массивов с заданием крайней гармоники и делителя орбиса
    public Матрица(ArrayList <Астра> массив1, ArrayList<Астра> массив2, int крайняяГармоника, int делительОрбиса) {
        this.крайняяГармоника = крайняяГармоника;
        this.делительОрбиса = делительОрбиса;
        тип = СИНАСТРИЯ;
        резонансы = new Резонанс[массив1.size()][массив2.size()];
        данные1 = массив1;
        данные2 = массив2;
        заполнитьМатрицу();
    }
    // из двух массивов б/доп-параметров
    public Матрица(ArrayList <Астра> массив1, ArrayList<Астра> массив2) {
        тип = СИНАСТРИЯ;
        крайняяГармоника = Настройки.выводКрайнейГармоники();
        делительОрбиса = Настройки.выводДелителяОрбиса();
        резонансы = new Резонанс[массив1.size()][массив2.size()];
        данные1 = массив1;
        данные2 = массив2;
        заполнитьМатрицу();
    }
    // из одного массива (сам на себя) б/доп-параметров
    public Матрица(ArrayList<Астра> массив) {
        тип = КОСМОГРАММА;
        крайняяГармоника = Настройки.выводКрайнейГармоники();
        делительОрбиса = Настройки.выводДелителяОрбиса();
        резонансы = new Резонанс[массив.size()][массив.size()];
        данные1 = массив;
        данные2 = массив;
        заполнитьМатрицу();
    }

    private void заполнитьМатрицу(){
        for (int i = 0; i < данные1.size(); i++)
            for (int j = 0; j < данные2.size(); j++)
                резонансы[i][j] = new Резонанс(данные1.get(i), данные2.get(j), КРУГ / делительОрбиса, крайняяГармоника);
    }
}
