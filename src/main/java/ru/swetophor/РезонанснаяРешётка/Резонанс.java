package ru.swetophor.РезонанснаяРешётка;

import АстроВидья.НебеснаяМеханика.*;
import java.util.ArrayList;
import static java.lang.Math.abs;
import static java.lang.Math.floor;
import static АстроВидья.НебеснаяМеханика.Механика.*;
import static АстроВидья.Толкователь.описаниеРезонанса;
import static АстроВидья.РезонанснаяРешётка.ТипРезонанса.*;

/** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Структурированный массив, описывающий                      *
 * взаимодействие (резонансы) между некоторыми двумя точками  *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/

public class Резонанс {

    private Карта чьяПервая;
    private Карта чьяВторая;
    private ТипРезонанса тип;
    private String первая;                  // название первой астры
    private String вторая;                  // название второй астры
    private double дуга;                  // угловое расстояние меж точками
    private double орбис;                 // допуск, с которым аспект считается действующим
    private int крайняяГармоника;           // наибольший целочисленный резонанс, иже проверяем
    private ArrayList<Созвук> созвуки;     // найденные в пределах орбиса резонансы по росту гармоники
    private ArrayList<Созвук> созвукиПоСиле;     // найденные в пределах орбиса резонансы убыванию силы

    // методы открытаго доступа к внутренним полям
    public double выводДуги() { return дуга; }
    public void вводДуги(double дуга) { this.дуга = дуга; }
    public double выводОрбиса() { return орбис; }
    public void вводОрбиса(double орбис) { this.орбис = орбис; }

    // один из действующих для данной дуги резонансов
    class Созвук {
        int число;              // гармоника
        int крат;               // дальность
        double зазор;           // орбис для соединения в этой гармонике
        double сила;            // тот же орбис в % от наиточнаго
        int глубина;            // он же через количество последующих гармоник, через кои проходит
        String степеньСилы() {
            if (глубина <= 1) return "- приблизительный ";
            else if (глубина <= 2) return "- уверенный ";
            else if (глубина <= 5) return "- глубокий ";
            else if (глубина <= 12) return "- точный ";
            else if (глубина <= 24) return "- глубоко точный ";
            else return "- крайне точный ";
        }
        Созвук(int число, double зазор, double отДуги) {
            this.число = число;
            this.крат = найтиКрат(число, отДуги);
            this.зазор = зазор;
            this.сила = ((орбис - зазор) / орбис) * 100;
            this.глубина = (int) floor(орбис/зазор);
        }
    }

    // получение массива резонансов для двух астр (конструктор)
    Резонанс(Астра а, Астра б, double орбис, int крайняяГармоника) {
        первая = а.имя; чьяПервая = а.небо;
        if (а.equals(б)) тип = САМА;
        else {
            вторая = б.имя; чьяВторая = б.небо;
            if(чьяПервая.выводИмени().equals(чьяВторая.выводИмени())) тип = КАРТА;
            else тип = СИНАСТРИЯ;
            первая = а.имя; вторая = б.имя;
            дуга = получитьДугу(а, б);
            this.орбис = орбис; this.крайняяГармоника = крайняяГармоника;
            созвуки = new ArrayList<>(); созвукиПоСиле = new ArrayList<>();
            double дугаГармоники;
            for (int i = 1; i <= крайняяГармоника; i++) {
                дугаГармоники = привестиАспект(дуга * i);
                if (дугаГармоники < орбис && !кратна(i))
                    созвуки.add(new Созвук(i, дугаГармоники, дуга));
            }
            упорядочить();
        }
    }

    // вспомогательный метод нахождения крата аспекта
    private int найтиКрат(int резонанс, double дуга) {
//        double единичник = 360 / резонанс;
        int крат = 1;
        while (крат < резонанс / 2) {
            if (abs(крат * КРУГ / резонанс - дуга) < орбис / резонанс) break;
            else крат++;
        }
        return крат;
    }

    // вспомогательный метод отсечения кратных гармоник
    private boolean кратна(int кто) {
        for (Созвук этот : созвуки) {
            if (этот.число == 1) continue;
            if(кто % этот.число == 0) return true;
        }
        return false;
    }
    // вспомогательный метод вывода созвуков
    private void выводСозвуков() {
        if (созвуки.size() == 0)
            System.out.println("Ни однаго резонанса до " + крайняяГармоника + " при орбисе " + орбис + "!");
        for (Созвук аспект : созвукиПоСиле) {
            System.out.print(описаниеРезонанса(аспект.число, аспект.крат));
            System.out.printf("Резонанс %d (x%d) %s (%d) (%.2f%%, %s)%n",
                    аспект.число, аспект.крат, аспект.степеньСилы(), аспект.глубина,
                    аспект.сила, секундФормат(аспект.зазор, true));
        }
    }

    // метод получения упорядоченнаго по силе
    private void упорядочить() {
        while (созвукиПоСиле.size() < созвуки.size()) {
            int сильнейший = 0;
            while (созвукиПоСиле.contains(созвуки.get(сильнейший))) сильнейший++;
            if (созвукиПоСиле.size() < созвуки.size() - 1) {
                int сильный = сильнейший + 1;
                while (созвукиПоСиле.contains(созвуки.get(сильный))) сильный++;
                while (сильный < созвуки.size()) {
                    if (созвуки.get(сильный).зазор < созвуки.get(сильнейший).зазор) сильнейший = сильный;
                    сильный++;
                    while (сильный < созвуки.size() && созвукиПоСиле.contains(созвуки.get(сильный))) сильный++;
                }
            }
            созвукиПоСиле.add(созвуки.get(сильнейший));
        }
    }

    // текстовой вывод данных по резонансу
    public void выводРезонансов() {
        switch (тип) {
            case САМА :
                System.out.printf("%n%s (%s)%n", первая, чьяПервая.выводИмени());
                break;
            case КАРТА:
                System.out.printf("%n* Дуга между %s и %s (%s) = %s%n",
                        первая, вторая, чьяПервая.выводИмени(), секундФормат(дуга, true));
                выводСозвуков();
                break;
            case СИНАСТРИЯ:
                System.out.printf("%n* Дуга между %s (%s) и %s (%s) = %s%n",
                        первая, чьяПервая.выводИмени(), вторая, чьяВторая.выводИмени(), секундФормат(дуга, true));
                выводСозвуков();
        }
    }
}
